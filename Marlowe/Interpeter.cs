using Antlr4.Runtime;
using Marlowe.CSharp;
using Marlowe.Logger;
using Marlowe.Utilities;
using System;
using System.Collections.Generic;



namespace Marlowe
{
    /// <summary>
    ///     The executation engine of <see cref="Marlowe"/>. Interprets the content
    ///     generated by the Symbol Table collection and attempts to execute the codes entrypoint.
    /// </summary>
    public class Interpeter : ComputableAPI, IInterpetable
    {
        private static List<SymbolTable> SymbolTables = new List<SymbolTable>();
        private readonly EntryPointCriteria Criteria;
        private CSharpVisitor EntryPoint;
        private SymbolFunctionNode MainFunction;

        public Interpeter(List<SymbolTable> symbolTables)
        {
            Criteria = new EntryPointCriteria();
            SymbolTables = symbolTables;
        }
        public Interpeter(List<SymbolTable> symbolTables, ILogger logger)
        {
            Criteria = new EntryPointCriteria();
            SymbolTables = symbolTables;
            Logger = logger;
        }

        /// <summary>
        ///     Executes the Interpeter engines. discovers entrypoint into the provided code and
        ///     intepeters the context.
        /// </summary>
        public void Execute()
        {
            if (HasEntryPoint())
            {

                AddUsingDirective();

                // this ensures that the visitor shares the same context as the visitor
                EntryPoint.ClassName = MainFunction.ClassName;
                EntryPoint.Namespace = MainFunction.Namespace;
                EntryPoint.criteria = Criteria;
                EntryPoint.VisitMethod_body((CSharpParser.Method_bodyContext)MainFunction.RuleContext);
            }

            else
            {
                if (Logger != null)
                {
                    Logger.WriteContent("No EntryPoint exists in this code.");
                    if(SymbolTables.Count > 0)
                    {
                        foreach (SymbolTable symbolTable in SymbolTables)
                        {
                            Logger.LogSymbolTable(symbolTable);
                        }
                    }
                }
            }
        }


        /// <summary>
        ///     Logs a class table representation of the code post execution.
        /// </summary>
        /// <param name="logger"></param>
        public void LogExecutedSymbolTable(ILogger logger)
        {
            if(logger != null)
            {
                Logger = logger;
            }
            LogExecutedSymbolTable();
        }


        /// <summary>
        ///     Logs a class table representation of the code post execution.
        /// </summary>
        public void LogExecutedSymbolTable()
        {

            Logger.WriteSymbolNode(EntryPoint.Variables, "Variables");
            Logger.WriteFunctionNode(EntryPoint.Functions, "Functions");

        }

        /// <summary>
        ///     Adds using directives to <see cref="EntryPoint"/>.
        /// </summary>
        private void AddUsingDirective()
        {
            foreach (var directive in EntryPoint.Directives)
            {
                foreach (var SymbolTable in SymbolTables)
                {
                    foreach (var item in SymbolTable.Variables)
                    {
                        if(item.Value.Namespace == directive.Key)
                        {
                            EntryPoint.Variables.Add(item.Key, item.Value);
                        }
                    }
                    foreach (var item in SymbolTable.Functions)
                    {
                        if (item.Value.Namespace == directive.Key)
                        {
                            try
                            {
                                EntryPoint.Functions.Add(item.Key, item.Value);
                            }
                            catch
                            {

                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        ///     Uses the <see cref="SymbolTable"/> to generate dynamic classs which will have the properities of the class files.
        /// </summary>
        /// <returns>a collection of dynamically created classes</returns>
        public List<object> GenerateClassContext()
        {
            List<object> newClassObjects = new List<object>();
            foreach (SymbolTable symbolTable in SymbolTables)
            {
                object newType = (SymbolNodeToClassBuilder.CreateNewObject(symbolTable));
                newClassObjects.Add(newType);
                Console.WriteLine("Sucessfully created class \t" + newType.GetType() + " \nIt has the following properities:");

            }
            return newClassObjects;
        }

        /// <summary>
        ///     Parses through <see cref="SymbolTables"/> to find static void Main(string[] args) entry point.
        /// </summary>
        /// <returns></returns>
        private bool HasEntryPoint()
        {
            foreach (SymbolTable symbolTable in SymbolTables)
            {
                foreach (KeyValuePair<string, SymbolFunctionNode> functions in symbolTable.Functions)
                {
                    if (functions.Key.ToUpper().Equals("MAIN")) // Checks for main function in class
                    {
                        SymbolFunctionNode paramatars = (SymbolFunctionNode)functions.Value;
                        Criteria.SetMainFunctionExists(true);
                        foreach (KeyValuePair<string, SymbolNode> param in paramatars.Paramaters)
                        {
                            if (param.Key.ToUpper().Equals("ARGS") && param.Value.Type == typeof(string))   // Checks for string args array
                            {
                                Criteria.SetMainArgs(true);
                                MainFunction = functions.Value;
                                break;
                            }
                            else
                            {
                                Criteria.SetMainFunctionExists(false);
                            }
                        }
                    }
                }
                if (Criteria.EntryPointFound())
                {
                    EntryPoint = (CSharpVisitor)symbolTable;
                    break;
                }
            }
            return Criteria.EntryPointFound();
        }
    }
}
