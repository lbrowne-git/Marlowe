using Marlowe.CSharp;
using Marlowe.Logger;
using Marlowe.Utilities;
using System;
using System.Collections.Generic;
using System.IO;

namespace Marlowe
{
    /// <summary>
    ///     The executation engine of <see cref="Marlowe"/>. Interprets the content
    ///     generated by the Symbol Table collection and attempts to execute the codes entrypoint.
    /// </summary>
    public class Interpeter : ComputableAPI, IInterpetable
    {
        private static List<SymbolTable> SymbolTables = new List<SymbolTable>();
        private readonly EntryPointCriteria Criteria;
        private CSharpVisitor EntryPoint;
        private SymbolFunctionNode MainFunction;

        public Interpeter(List<SymbolTable> symbolTables)
        {
            Criteria = new EntryPointCriteria();
            SymbolTables = symbolTables;
        }
        public Interpeter(List<SymbolTable> symbolTables, ILogger logger)
        {
            Criteria = new EntryPointCriteria();
            SymbolTables = symbolTables;
            Logger = logger;
        }
        public Interpeter(List<string> Files, ILogger logger)
        {
            Criteria = new EntryPointCriteria();
            Logger = logger;
            ExecuteAnalyser(Files);
        }



        /// <summary>
        ///     Executes the Interpeter engines. discovers entrypoint into the provided code and
        ///     intepeters the context.
        /// </summary>
        public void Execute()
        {
            if (HasEntryPoint())
            {

                AddUsingDirective();

                // this ensures that the visitor shares the same context as the visitor
                EntryPoint.ClassName = MainFunction.ClassName;
                EntryPoint.Namespace = MainFunction.Namespace;
                EntryPoint.criteria = Criteria;
                EntryPoint.VisitMethod_body((CSharpParser.Method_bodyContext)MainFunction.RuleContext);
            }

            else
            {
                if (Logger != null)
                {
                    Logger.WriteContent("No EntryPoint exists in this code.");
                    if (SymbolTables.Count > 0)
                    {
                        foreach (SymbolTable symbolTable in SymbolTables)
                        {
                            Logger.LogSymbolTable(symbolTable);
                        }
                    }
                }
            }
        }


        /// <summary>
        ///     Logs a class table representation of the code post execution.
        /// </summary>
        /// <param name="logger"></param>
        public void LogExecutedSymbolTable(ILogger logger)
        {
            if (logger != null)
            {
                Logger = logger;
            }
            LogExecutedSymbolTable();
        }


        /// <summary>
        ///     Logs a class table representation of the code post execution.
        /// </summary>
        public void LogExecutedSymbolTable()
        {
            if(Logger != null)
            {
                Logger.WriteSymbolNode(EntryPoint.Variables, "Variables");
                Logger.WriteFunctionNode(EntryPoint.Functions, "Functions");
            }

        }

        /// <summary>
        ///     Adds accumalated using references throughout files<see cref="EntryPoint"/>.
        /// </summary>
        private void AddUsingDirective()
        {
            foreach (var directive in EntryPoint.Directives)
            {
                foreach (var SymbolTable in SymbolTables)
                {
                    foreach (var item in SymbolTable.Variables)
                    {
                        if (item.Value.Namespace == directive.Key)
                        {
                            EntryPoint.Variables.Add(item.Key, item.Value);
                        }
                    }
                    foreach (var item in SymbolTable.Functions)
                    {
                        if (item.Value.Namespace == directive.Key)
                        {
                            try
                            {
                                EntryPoint.Functions.Add(item.Key, item.Value);
                            }
                            catch
                            {

                            }
                        }
                    }
                }
            }
        }
        /// <summary>
        ///     Generates a list of class objects that can be gotten using <see cref="GetClassObject(string)"/> or <see cref="GetClassObjects(List{string})"/>.
        ///     This is done by making use of the concrete implementation of <see cref="Analyser"/>, and its analyser type can be changed.</summary>
        ///     
        /// <remarks>
        ///     This is <see langword="static"/> so it can be used with <see cref="Main(string[])"/>.
        /// </remarks>
        /// <param name="files">A collection of files that will analysed by the system</param>.
        public void ExecuteAnalyser(List<string> files)
        {
            foreach (string file in files)  // passes through each file in a directory
            {
                try
                {
                    string FileContents = File.ReadAllText(file);

                    Analyser analyser = new CSharpAnalyser(FileContents);
                    analyser.CommonTokenStream.Fill();

                    // Casts the abstract Analyser types to their CSharp implementation.
                    CSharpParser codeParser = (CSharpParser)analyser.Parser;
                    codeParser.RemoveErrorListeners();
                    CSharpVisitor cSharpVisitor = (CSharpVisitor)analyser.Visitor;
                    cSharpVisitor.VisitCompilation_unit(codeParser.compilation_unit());


                    //Populates with a file's SymbolTable.
                    SymbolTables.Add(cSharpVisitor);

                }
                catch (Exception ex)
                {
                    Console.WriteLine("Error: " + ex);
                }
            }
        }


        public List<object> GetClassObjects(List<string> files)
        {
            ExecuteAnalyser(files);
            return NodeObjects;
        }

        public List<object> GetClassObject(string file)
        {
            ExecuteAnalyser(new List<string>() { file });
            return NodeObjects;
        }
        /// <summary>
        ///Handles the CLI of this applicaiton
        /// </summary>


        /// <summary>
        ///     Uses the <see cref="SymbolTable"/> to generate dynamic classs which will have the properities of the class files.
        /// </summary>
        /// <returns>a collection of dynamically created classes</returns>
        public List<object> GenerateClassContext()
        {
            List<object> newClassObjects = new List<object>();
            foreach (SymbolTable symbolTable in SymbolTables)
            {
                object newType = (SymbolNodeToClassBuilder.CreateNewObject(symbolTable));
                newClassObjects.Add(newType);
                Console.WriteLine("Sucessfully created class \t" + newType.GetType() + " \nIt has the following properities:");

            }
            return newClassObjects;
        }

        /// <summary>
        ///     Parses through <see cref="SymbolTables"/> to find static void Main(string[] args) entry point.
        /// </summary>
        /// <returns></returns>
        private bool HasEntryPoint()
        {
            foreach (SymbolTable symbolTable in SymbolTables)
            {
                foreach (KeyValuePair<string, SymbolFunctionNode> functions in symbolTable.Functions)
                {
                    if (!functions.Key.ToUpper().Equals("MAIN")) // Checks for main function in class
                    {
                        break;
                    }
                    SymbolFunctionNode paramatars = (SymbolFunctionNode)functions.Value;
                    Criteria.SetMainFunctionExists(true);
                    foreach (KeyValuePair<string, SymbolNode> param in paramatars.Paramaters)
                    {
                        if (param.Key.ToUpper().Equals("ARGS") && param.Value.ClassType == typeof(string))   // Checks for string args array
                        {
                            Criteria.SetMainArgs(true);

                            MainFunction = functions.Value;
                            break;
                        }
                        else
                        {
                            Criteria.SetMainFunctionExists(false);
                        }
                    }

                }
                if (Criteria.EntryPointFound())
                {
                    EntryPoint = (CSharpVisitor)symbolTable;
                    break;
                }
            }
            return Criteria.EntryPointFound();
        }
    }
}
